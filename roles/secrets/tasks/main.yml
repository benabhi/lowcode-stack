# ==============================================================================
# Secrets Role - Main Tasks
# ==============================================================================
# This role auto-generates and manages all service secrets.
# Secrets are stored on the server and MERGED on subsequent deployments.
# Existing secrets are NEVER overwritten - only missing ones are added.
# ==============================================================================

---
- name: Ensure base directory exists
  ansible.builtin.file:
    path: "{{ lowcode_base_path }}"
    state: directory
    owner: root
    group: root
    mode: "0755"

- name: Check if secrets file exists
  ansible.builtin.stat:
    path: "{{ secrets_file_path }}"
  register: secrets_file_stat

# ==============================================================================
# SCENARIO 1: First deployment - Generate all secrets
# ==============================================================================
- name: Generate new secrets (first deployment)
  when: not secrets_file_stat.stat.exists
  block:
    - name: Generate all random secrets
      ansible.builtin.set_fact:
        generated_secrets:
          # =================================================================
          # Core Services
          # =================================================================
          # Supabase
          supabase_postgres_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          supabase_jwt_secret: "{{ lookup('community.general.random_string', length=43, special=false, base64=true) }}"
          supabase_dashboard_username: "admin"
          supabase_dashboard_password: "{{ lookup('community.general.random_string', length=16, special=false) }}"
          # n8n
          n8n_encryption_key: "{{ lookup('community.general.random_string', length=32, special=false) | hash('md5') }}"
          n8n_basic_auth_user: "admin"
          n8n_basic_auth_password: "{{ lookup('community.general.random_string', length=16, special=false) }}"
          n8n_redis_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          # Appsmith
          appsmith_encryption_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          appsmith_encryption_salt: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          # Redis (shared - for development only)
          redis_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          # Nginx Basic Auth
          nginx_htpasswd_username: "admin"
          nginx_htpasswd_password: "{{ lookup('community.general.random_string', length=16, special=false) }}"
          # =================================================================
          # Optional Services
          # =================================================================
          # Gitea
          gitea_db_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          # Docmost
          docmost_db_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          docmost_redis_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          docmost_app_secret: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          # Generation timestamp
          generated_at: "{{ ansible_date_time.iso8601 }}"

    - name: Generate Supabase JWT keys using Python
      ansible.builtin.shell: |
        python3 << 'PYTHON_SCRIPT'
        import base64
        import hmac
        import hashlib
        import json
        import time

        jwt_secret = "{{ generated_secrets.supabase_jwt_secret }}"

        def create_jwt(secret, role):
            # Header
            header = {"alg": "HS256", "typ": "JWT"}
            header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).rstrip(b'=').decode()

            # Payload - expires in 10 years
            exp = int(time.time()) + (10 * 365 * 24 * 60 * 60)
            payload = {
                "role": role,
                "iss": "supabase",
                "iat": int(time.time()),
                "exp": exp
            }
            payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).rstrip(b'=').decode()

            # Signature
            message = f"{header_b64}.{payload_b64}"
            signature = hmac.new(secret.encode(), message.encode(), hashlib.sha256).digest()
            signature_b64 = base64.urlsafe_b64encode(signature).rstrip(b'=').decode()

            return f"{header_b64}.{payload_b64}.{signature_b64}"

        anon_key = create_jwt(jwt_secret, "anon")
        service_key = create_jwt(jwt_secret, "service_role")

        print(f"ANON_KEY={anon_key}")
        print(f"SERVICE_KEY={service_key}")
        PYTHON_SCRIPT
      register: jwt_generation_result
      changed_when: false

    - name: Parse generated JWT keys
      ansible.builtin.set_fact:
        supabase_anon_key: "{{ jwt_generation_result.stdout_lines | select('match', '^ANON_KEY=') | first | regex_replace('^ANON_KEY=', '') }}"
        supabase_service_key: "{{ jwt_generation_result.stdout_lines | select('match', '^SERVICE_KEY=') | first | regex_replace('^SERVICE_KEY=', '') }}"

    - name: Add JWT keys to secrets
      ansible.builtin.set_fact:
        generated_secrets: "{{ generated_secrets | combine({
          'supabase_anon_key': supabase_anon_key,
          'supabase_service_role_key': supabase_service_key
        }) }}"

    - name: Save secrets to server
      ansible.builtin.copy:
        content: "{{ generated_secrets | to_nice_yaml }}"
        dest: "{{ secrets_file_path }}"
        owner: "{{ secrets_file_owner }}"
        group: "{{ secrets_file_group }}"
        mode: "{{ secrets_file_mode }}"

    - name: Set flag for new secrets
      ansible.builtin.set_fact:
        secrets_newly_generated: true

# ==============================================================================
# SCENARIO 2: Existing deployment - Merge missing secrets only
# ==============================================================================
- name: Merge missing secrets (existing deployment)
  when: secrets_file_stat.stat.exists
  block:
    - name: Load existing secrets from file
      ansible.builtin.slurp:
        src: "{{ secrets_file_path }}"
      register: existing_secrets_content

    - name: Parse existing secrets
      ansible.builtin.set_fact:
        existing_secrets: "{{ existing_secrets_content.content | b64decode | from_yaml }}"

    - name: Define all secret keys with their generators
      ansible.builtin.set_fact:
        all_secret_defaults:
          # Core - only add if missing
          n8n_redis_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          # Optional services - only add if missing
          gitea_db_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          docmost_db_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          docmost_redis_password: "{{ lookup('community.general.random_string', length=32, special=false) }}"
          docmost_app_secret: "{{ lookup('community.general.random_string', length=32, special=false) }}"

    - name: Identify missing secrets
      ansible.builtin.set_fact:
        missing_secrets: "{{ all_secret_defaults | dict2items | rejectattr('key', 'in', existing_secrets.keys() | list) | list | items2dict }}"

    - name: Merge missing secrets with existing
      ansible.builtin.set_fact:
        generated_secrets: "{{ existing_secrets | combine(missing_secrets) }}"
      when: missing_secrets | length > 0

    - name: Use existing secrets if nothing missing
      ansible.builtin.set_fact:
        generated_secrets: "{{ existing_secrets }}"
      when: missing_secrets | length == 0

    - name: Save merged secrets to server
      ansible.builtin.copy:
        content: "{{ generated_secrets | to_nice_yaml }}"
        dest: "{{ secrets_file_path }}"
        owner: "{{ secrets_file_owner }}"
        group: "{{ secrets_file_group }}"
        mode: "{{ secrets_file_mode }}"
      when: missing_secrets | length > 0

    - name: Display added secrets info
      ansible.builtin.debug:
        msg: "Added {{ missing_secrets | length }} missing secret(s): {{ missing_secrets.keys() | list | join(', ') }}"
      when: missing_secrets | length > 0

# ==============================================================================
# Load final secrets for use by other roles
# ==============================================================================
- name: Load secrets from file
  ansible.builtin.slurp:
    src: "{{ secrets_file_path }}"
  register: secrets_file_content

- name: Parse secrets
  ansible.builtin.set_fact:
    lowcode_secrets: "{{ secrets_file_content.content | b64decode | from_yaml }}"

- name: Display generated secrets summary
  when: secrets_newly_generated | default(false) and secrets_display_on_create
  ansible.builtin.debug:
    msg:
      - "SECRETOS GENERADOS - Guardar en lugar seguro"
      - "Archivo: {{ secrets_file_path }}"
      - "---"
      - "SUPABASE: user={{ lowcode_secrets.supabase_dashboard_username }} pass={{ lowcode_secrets.supabase_dashboard_password }}"
      - "N8N: user={{ lowcode_secrets.n8n_basic_auth_user }} pass={{ lowcode_secrets.n8n_basic_auth_password }}"
      - "NGINX (Supabase Studio): user={{ lowcode_secrets.nginx_htpasswd_username }} pass={{ lowcode_secrets.nginx_htpasswd_password }}"
      - "APPSMITH: Crear usuario en primer acceso web"
      - "---"
      - "URLs: https://{{ lowcode_domain_supabase }} | https://{{ lowcode_domain_n8n }} | https://{{ lowcode_domain_appsmith }}"

- name: Confirm secrets loaded
  ansible.builtin.debug:
    msg: "Secrets loaded from {{ secrets_file_path }} (generated: {{ lowcode_secrets.generated_at | default('unknown') }})"
  when: not (secrets_newly_generated | default(false))
